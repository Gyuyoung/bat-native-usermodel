// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pipeline.proto

#ifndef PROTOBUF_INCLUDED_pipeline_2eproto
#define PROTOBUF_INCLUDED_pipeline_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_pipeline_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_pipeline_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_pipeline_2eproto();
namespace pipelines {
class Classifier;
class ClassifierDefaultTypeInternal;
extern ClassifierDefaultTypeInternal _Classifier_default_instance_;
class Hash_ngram;
class Hash_ngramDefaultTypeInternal;
extern Hash_ngramDefaultTypeInternal _Hash_ngram_default_instance_;
class Linear_classifier;
class Linear_classifierDefaultTypeInternal;
extern Linear_classifierDefaultTypeInternal _Linear_classifier_default_instance_;
class Naive_bayes;
class Naive_bayesDefaultTypeInternal;
extern Naive_bayesDefaultTypeInternal _Naive_bayes_default_instance_;
class Pipeline;
class PipelineDefaultTypeInternal;
extern PipelineDefaultTypeInternal _Pipeline_default_instance_;
class To_lower;
class To_lowerDefaultTypeInternal;
extern To_lowerDefaultTypeInternal _To_lower_default_instance_;
class Transformation;
class TransformationDefaultTypeInternal;
extern TransformationDefaultTypeInternal _Transformation_default_instance_;
class Vector;
class VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
}  // namespace pipelines
namespace google {
namespace protobuf {
template<> ::pipelines::Classifier* Arena::CreateMaybeMessage<::pipelines::Classifier>(Arena*);
template<> ::pipelines::Hash_ngram* Arena::CreateMaybeMessage<::pipelines::Hash_ngram>(Arena*);
template<> ::pipelines::Linear_classifier* Arena::CreateMaybeMessage<::pipelines::Linear_classifier>(Arena*);
template<> ::pipelines::Naive_bayes* Arena::CreateMaybeMessage<::pipelines::Naive_bayes>(Arena*);
template<> ::pipelines::Pipeline* Arena::CreateMaybeMessage<::pipelines::Pipeline>(Arena*);
template<> ::pipelines::To_lower* Arena::CreateMaybeMessage<::pipelines::To_lower>(Arena*);
template<> ::pipelines::Transformation* Arena::CreateMaybeMessage<::pipelines::Transformation>(Arena*);
template<> ::pipelines::Vector* Arena::CreateMaybeMessage<::pipelines::Vector>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pipelines {

// ===================================================================

class To_lower :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pipelines.To_lower) */ {
 public:
  To_lower();
  virtual ~To_lower();

  To_lower(const To_lower& from);

  inline To_lower& operator=(const To_lower& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  To_lower(To_lower&& from) noexcept
    : To_lower() {
    *this = ::std::move(from);
  }

  inline To_lower& operator=(To_lower&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const To_lower& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const To_lower* internal_default_instance() {
    return reinterpret_cast<const To_lower*>(
               &_To_lower_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(To_lower* other);
  friend void swap(To_lower& a, To_lower& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline To_lower* New() const final {
    return CreateMaybeMessage<To_lower>(nullptr);
  }

  To_lower* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<To_lower>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const To_lower& from);
  void MergeFrom(const To_lower& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(To_lower* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pipelines.To_lower)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Hash_ngram :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pipelines.Hash_ngram) */ {
 public:
  Hash_ngram();
  virtual ~Hash_ngram();

  Hash_ngram(const Hash_ngram& from);

  inline Hash_ngram& operator=(const Hash_ngram& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Hash_ngram(Hash_ngram&& from) noexcept
    : Hash_ngram() {
    *this = ::std::move(from);
  }

  inline Hash_ngram& operator=(Hash_ngram&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Hash_ngram& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Hash_ngram* internal_default_instance() {
    return reinterpret_cast<const Hash_ngram*>(
               &_Hash_ngram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Hash_ngram* other);
  friend void swap(Hash_ngram& a, Hash_ngram& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Hash_ngram* New() const final {
    return CreateMaybeMessage<Hash_ngram>(nullptr);
  }

  Hash_ngram* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Hash_ngram>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Hash_ngram& from);
  void MergeFrom(const Hash_ngram& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hash_ngram* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 hash_sizes = 2;
  int hash_sizes_size() const;
  void clear_hash_sizes();
  static const int kHashSizesFieldNumber = 2;
  ::google::protobuf::int32 hash_sizes(int index) const;
  void set_hash_sizes(int index, ::google::protobuf::int32 value);
  void add_hash_sizes(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hash_sizes() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hash_sizes();

  // int32 num_buckets = 1;
  void clear_num_buckets();
  static const int kNumBucketsFieldNumber = 1;
  ::google::protobuf::int32 num_buckets() const;
  void set_num_buckets(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pipelines.Hash_ngram)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hash_sizes_;
  mutable std::atomic<int> _hash_sizes_cached_byte_size_;
  ::google::protobuf::int32 num_buckets_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Transformation :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pipelines.Transformation) */ {
 public:
  Transformation();
  virtual ~Transformation();

  Transformation(const Transformation& from);

  inline Transformation& operator=(const Transformation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transformation(Transformation&& from) noexcept
    : Transformation() {
    *this = ::std::move(from);
  }

  inline Transformation& operator=(Transformation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Transformation& default_instance();

  enum RepresentationCase {
    kToLower = 1,
    kHashNgram = 2,
    REPRESENTATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transformation* internal_default_instance() {
    return reinterpret_cast<const Transformation*>(
               &_Transformation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Transformation* other);
  friend void swap(Transformation& a, Transformation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transformation* New() const final {
    return CreateMaybeMessage<Transformation>(nullptr);
  }

  Transformation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transformation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transformation& from);
  void MergeFrom(const Transformation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transformation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pipelines.To_lower to_lower = 1;
  bool has_to_lower() const;
  void clear_to_lower();
  static const int kToLowerFieldNumber = 1;
  const ::pipelines::To_lower& to_lower() const;
  ::pipelines::To_lower* release_to_lower();
  ::pipelines::To_lower* mutable_to_lower();
  void set_allocated_to_lower(::pipelines::To_lower* to_lower);

  // .pipelines.Hash_ngram hash_ngram = 2;
  bool has_hash_ngram() const;
  void clear_hash_ngram();
  static const int kHashNgramFieldNumber = 2;
  const ::pipelines::Hash_ngram& hash_ngram() const;
  ::pipelines::Hash_ngram* release_hash_ngram();
  ::pipelines::Hash_ngram* mutable_hash_ngram();
  void set_allocated_hash_ngram(::pipelines::Hash_ngram* hash_ngram);

  void clear_Representation();
  RepresentationCase Representation_case() const;
  // @@protoc_insertion_point(class_scope:pipelines.Transformation)
 private:
  class HasBitSetters;
  void set_has_to_lower();
  void set_has_hash_ngram();

  inline bool has_Representation() const;
  inline void clear_has_Representation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RepresentationUnion {
    RepresentationUnion() {}
    ::pipelines::To_lower* to_lower_;
    ::pipelines::Hash_ngram* hash_ngram_;
  } Representation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Vector :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pipelines.Vector) */ {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Vector* other);
  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector* New() const final {
    return CreateMaybeMessage<Vector>(nullptr);
  }

  Vector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float elements = 1;
  int elements_size() const;
  void clear_elements();
  static const int kElementsFieldNumber = 1;
  float elements(int index) const;
  void set_elements(int index, float value);
  void add_elements(float value);
  const ::google::protobuf::RepeatedField< float >&
      elements() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_elements();

  // @@protoc_insertion_point(class_scope:pipelines.Vector)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< float > elements_;
  mutable std::atomic<int> _elements_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Naive_bayes :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pipelines.Naive_bayes) */ {
 public:
  Naive_bayes();
  virtual ~Naive_bayes();

  Naive_bayes(const Naive_bayes& from);

  inline Naive_bayes& operator=(const Naive_bayes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Naive_bayes(Naive_bayes&& from) noexcept
    : Naive_bayes() {
    *this = ::std::move(from);
  }

  inline Naive_bayes& operator=(Naive_bayes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Naive_bayes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Naive_bayes* internal_default_instance() {
    return reinterpret_cast<const Naive_bayes*>(
               &_Naive_bayes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Naive_bayes* other);
  friend void swap(Naive_bayes& a, Naive_bayes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Naive_bayes* New() const final {
    return CreateMaybeMessage<Naive_bayes>(nullptr);
  }

  Naive_bayes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Naive_bayes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Naive_bayes& from);
  void MergeFrom(const Naive_bayes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Naive_bayes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string classes = 1;
  int classes_size() const;
  void clear_classes();
  static const int kClassesFieldNumber = 1;
  const ::std::string& classes(int index) const;
  ::std::string* mutable_classes(int index);
  void set_classes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_classes(int index, ::std::string&& value);
  #endif
  void set_classes(int index, const char* value);
  void set_classes(int index, const char* value, size_t size);
  ::std::string* add_classes();
  void add_classes(const ::std::string& value);
  #if LANG_CXX11
  void add_classes(::std::string&& value);
  #endif
  void add_classes(const char* value);
  void add_classes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& classes() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_classes();

  // repeated .pipelines.Vector vectors = 2;
  int vectors_size() const;
  void clear_vectors();
  static const int kVectorsFieldNumber = 2;
  ::pipelines::Vector* mutable_vectors(int index);
  ::google::protobuf::RepeatedPtrField< ::pipelines::Vector >*
      mutable_vectors();
  const ::pipelines::Vector& vectors(int index) const;
  ::pipelines::Vector* add_vectors();
  const ::google::protobuf::RepeatedPtrField< ::pipelines::Vector >&
      vectors() const;

  // repeated float class_priors = 3;
  int class_priors_size() const;
  void clear_class_priors();
  static const int kClassPriorsFieldNumber = 3;
  float class_priors(int index) const;
  void set_class_priors(int index, float value);
  void add_class_priors(float value);
  const ::google::protobuf::RepeatedField< float >&
      class_priors() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_class_priors();

  // @@protoc_insertion_point(class_scope:pipelines.Naive_bayes)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> classes_;
  ::google::protobuf::RepeatedPtrField< ::pipelines::Vector > vectors_;
  ::google::protobuf::RepeatedField< float > class_priors_;
  mutable std::atomic<int> _class_priors_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Linear_classifier :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pipelines.Linear_classifier) */ {
 public:
  Linear_classifier();
  virtual ~Linear_classifier();

  Linear_classifier(const Linear_classifier& from);

  inline Linear_classifier& operator=(const Linear_classifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Linear_classifier(Linear_classifier&& from) noexcept
    : Linear_classifier() {
    *this = ::std::move(from);
  }

  inline Linear_classifier& operator=(Linear_classifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Linear_classifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Linear_classifier* internal_default_instance() {
    return reinterpret_cast<const Linear_classifier*>(
               &_Linear_classifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Linear_classifier* other);
  friend void swap(Linear_classifier& a, Linear_classifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Linear_classifier* New() const final {
    return CreateMaybeMessage<Linear_classifier>(nullptr);
  }

  Linear_classifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Linear_classifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Linear_classifier& from);
  void MergeFrom(const Linear_classifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Linear_classifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string classes = 1;
  int classes_size() const;
  void clear_classes();
  static const int kClassesFieldNumber = 1;
  const ::std::string& classes(int index) const;
  ::std::string* mutable_classes(int index);
  void set_classes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_classes(int index, ::std::string&& value);
  #endif
  void set_classes(int index, const char* value);
  void set_classes(int index, const char* value, size_t size);
  ::std::string* add_classes();
  void add_classes(const ::std::string& value);
  #if LANG_CXX11
  void add_classes(::std::string&& value);
  #endif
  void add_classes(const char* value);
  void add_classes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& classes() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_classes();

  // @@protoc_insertion_point(class_scope:pipelines.Linear_classifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> classes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Classifier :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pipelines.Classifier) */ {
 public:
  Classifier();
  virtual ~Classifier();

  Classifier(const Classifier& from);

  inline Classifier& operator=(const Classifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Classifier(Classifier&& from) noexcept
    : Classifier() {
    *this = ::std::move(from);
  }

  inline Classifier& operator=(Classifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Classifier& default_instance();

  enum ClassifierCase {
    kNb = 1,
    kLc = 2,
    CLASSIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Classifier* internal_default_instance() {
    return reinterpret_cast<const Classifier*>(
               &_Classifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Classifier* other);
  friend void swap(Classifier& a, Classifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Classifier* New() const final {
    return CreateMaybeMessage<Classifier>(nullptr);
  }

  Classifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Classifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Classifier& from);
  void MergeFrom(const Classifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Classifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pipelines.Naive_bayes nb = 1;
  bool has_nb() const;
  void clear_nb();
  static const int kNbFieldNumber = 1;
  const ::pipelines::Naive_bayes& nb() const;
  ::pipelines::Naive_bayes* release_nb();
  ::pipelines::Naive_bayes* mutable_nb();
  void set_allocated_nb(::pipelines::Naive_bayes* nb);

  // .pipelines.Linear_classifier lc = 2;
  bool has_lc() const;
  void clear_lc();
  static const int kLcFieldNumber = 2;
  const ::pipelines::Linear_classifier& lc() const;
  ::pipelines::Linear_classifier* release_lc();
  ::pipelines::Linear_classifier* mutable_lc();
  void set_allocated_lc(::pipelines::Linear_classifier* lc);

  void clear_classifier();
  ClassifierCase classifier_case() const;
  // @@protoc_insertion_point(class_scope:pipelines.Classifier)
 private:
  class HasBitSetters;
  void set_has_nb();
  void set_has_lc();

  inline bool has_classifier() const;
  inline void clear_has_classifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ClassifierUnion {
    ClassifierUnion() {}
    ::pipelines::Naive_bayes* nb_;
    ::pipelines::Linear_classifier* lc_;
  } classifier_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_pipeline_2eproto;
};
// -------------------------------------------------------------------

class Pipeline :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pipelines.Pipeline) */ {
 public:
  Pipeline();
  virtual ~Pipeline();

  Pipeline(const Pipeline& from);

  inline Pipeline& operator=(const Pipeline& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Pipeline(Pipeline&& from) noexcept
    : Pipeline() {
    *this = ::std::move(from);
  }

  inline Pipeline& operator=(Pipeline&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Pipeline& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Pipeline* internal_default_instance() {
    return reinterpret_cast<const Pipeline*>(
               &_Pipeline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Pipeline* other);
  friend void swap(Pipeline& a, Pipeline& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Pipeline* New() const final {
    return CreateMaybeMessage<Pipeline>(nullptr);
  }

  Pipeline* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Pipeline>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Pipeline& from);
  void MergeFrom(const Pipeline& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Pipeline* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pipelines.Transformation representation = 4;
  int representation_size() const;
  void clear_representation();
  static const int kRepresentationFieldNumber = 4;
  ::pipelines::Transformation* mutable_representation(int index);
  ::google::protobuf::RepeatedPtrField< ::pipelines::Transformation >*
      mutable_representation();
  const ::pipelines::Transformation& representation(int index) const;
  ::pipelines::Transformation* add_representation();
  const ::google::protobuf::RepeatedPtrField< ::pipelines::Transformation >&
      representation() const;

  // string language = 2;
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  #if LANG_CXX11
  void set_language(::std::string&& value);
  #endif
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // string timestamp = 3;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  const ::std::string& timestamp() const;
  void set_timestamp(const ::std::string& value);
  #if LANG_CXX11
  void set_timestamp(::std::string&& value);
  #endif
  void set_timestamp(const char* value);
  void set_timestamp(const char* value, size_t size);
  ::std::string* mutable_timestamp();
  ::std::string* release_timestamp();
  void set_allocated_timestamp(::std::string* timestamp);

  // .pipelines.Classifier classifier = 5;
  bool has_classifier() const;
  void clear_classifier();
  static const int kClassifierFieldNumber = 5;
  const ::pipelines::Classifier& classifier() const;
  ::pipelines::Classifier* release_classifier();
  ::pipelines::Classifier* mutable_classifier();
  void set_allocated_classifier(::pipelines::Classifier* classifier);

  // int32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pipelines.Pipeline)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pipelines::Transformation > representation_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr timestamp_;
  ::pipelines::Classifier* classifier_;
  ::google::protobuf::int32 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_pipeline_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// To_lower

// -------------------------------------------------------------------

// Hash_ngram

// int32 num_buckets = 1;
inline void Hash_ngram::clear_num_buckets() {
  num_buckets_ = 0;
}
inline ::google::protobuf::int32 Hash_ngram::num_buckets() const {
  // @@protoc_insertion_point(field_get:pipelines.Hash_ngram.num_buckets)
  return num_buckets_;
}
inline void Hash_ngram::set_num_buckets(::google::protobuf::int32 value) {
  
  num_buckets_ = value;
  // @@protoc_insertion_point(field_set:pipelines.Hash_ngram.num_buckets)
}

// repeated int32 hash_sizes = 2;
inline int Hash_ngram::hash_sizes_size() const {
  return hash_sizes_.size();
}
inline void Hash_ngram::clear_hash_sizes() {
  hash_sizes_.Clear();
}
inline ::google::protobuf::int32 Hash_ngram::hash_sizes(int index) const {
  // @@protoc_insertion_point(field_get:pipelines.Hash_ngram.hash_sizes)
  return hash_sizes_.Get(index);
}
inline void Hash_ngram::set_hash_sizes(int index, ::google::protobuf::int32 value) {
  hash_sizes_.Set(index, value);
  // @@protoc_insertion_point(field_set:pipelines.Hash_ngram.hash_sizes)
}
inline void Hash_ngram::add_hash_sizes(::google::protobuf::int32 value) {
  hash_sizes_.Add(value);
  // @@protoc_insertion_point(field_add:pipelines.Hash_ngram.hash_sizes)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
Hash_ngram::hash_sizes() const {
  // @@protoc_insertion_point(field_list:pipelines.Hash_ngram.hash_sizes)
  return hash_sizes_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
Hash_ngram::mutable_hash_sizes() {
  // @@protoc_insertion_point(field_mutable_list:pipelines.Hash_ngram.hash_sizes)
  return &hash_sizes_;
}

// -------------------------------------------------------------------

// Transformation

// .pipelines.To_lower to_lower = 1;
inline bool Transformation::has_to_lower() const {
  return Representation_case() == kToLower;
}
inline void Transformation::set_has_to_lower() {
  _oneof_case_[0] = kToLower;
}
inline void Transformation::clear_to_lower() {
  if (has_to_lower()) {
    delete Representation_.to_lower_;
    clear_has_Representation();
  }
}
inline ::pipelines::To_lower* Transformation::release_to_lower() {
  // @@protoc_insertion_point(field_release:pipelines.Transformation.to_lower)
  if (has_to_lower()) {
    clear_has_Representation();
      ::pipelines::To_lower* temp = Representation_.to_lower_;
    Representation_.to_lower_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pipelines::To_lower& Transformation::to_lower() const {
  // @@protoc_insertion_point(field_get:pipelines.Transformation.to_lower)
  return has_to_lower()
      ? *Representation_.to_lower_
      : *reinterpret_cast< ::pipelines::To_lower*>(&::pipelines::_To_lower_default_instance_);
}
inline ::pipelines::To_lower* Transformation::mutable_to_lower() {
  if (!has_to_lower()) {
    clear_Representation();
    set_has_to_lower();
    Representation_.to_lower_ = CreateMaybeMessage< ::pipelines::To_lower >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pipelines.Transformation.to_lower)
  return Representation_.to_lower_;
}

// .pipelines.Hash_ngram hash_ngram = 2;
inline bool Transformation::has_hash_ngram() const {
  return Representation_case() == kHashNgram;
}
inline void Transformation::set_has_hash_ngram() {
  _oneof_case_[0] = kHashNgram;
}
inline void Transformation::clear_hash_ngram() {
  if (has_hash_ngram()) {
    delete Representation_.hash_ngram_;
    clear_has_Representation();
  }
}
inline ::pipelines::Hash_ngram* Transformation::release_hash_ngram() {
  // @@protoc_insertion_point(field_release:pipelines.Transformation.hash_ngram)
  if (has_hash_ngram()) {
    clear_has_Representation();
      ::pipelines::Hash_ngram* temp = Representation_.hash_ngram_;
    Representation_.hash_ngram_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pipelines::Hash_ngram& Transformation::hash_ngram() const {
  // @@protoc_insertion_point(field_get:pipelines.Transformation.hash_ngram)
  return has_hash_ngram()
      ? *Representation_.hash_ngram_
      : *reinterpret_cast< ::pipelines::Hash_ngram*>(&::pipelines::_Hash_ngram_default_instance_);
}
inline ::pipelines::Hash_ngram* Transformation::mutable_hash_ngram() {
  if (!has_hash_ngram()) {
    clear_Representation();
    set_has_hash_ngram();
    Representation_.hash_ngram_ = CreateMaybeMessage< ::pipelines::Hash_ngram >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pipelines.Transformation.hash_ngram)
  return Representation_.hash_ngram_;
}

inline bool Transformation::has_Representation() const {
  return Representation_case() != REPRESENTATION_NOT_SET;
}
inline void Transformation::clear_has_Representation() {
  _oneof_case_[0] = REPRESENTATION_NOT_SET;
}
inline Transformation::RepresentationCase Transformation::Representation_case() const {
  return Transformation::RepresentationCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Vector

// repeated float elements = 1;
inline int Vector::elements_size() const {
  return elements_.size();
}
inline void Vector::clear_elements() {
  elements_.Clear();
}
inline float Vector::elements(int index) const {
  // @@protoc_insertion_point(field_get:pipelines.Vector.elements)
  return elements_.Get(index);
}
inline void Vector::set_elements(int index, float value) {
  elements_.Set(index, value);
  // @@protoc_insertion_point(field_set:pipelines.Vector.elements)
}
inline void Vector::add_elements(float value) {
  elements_.Add(value);
  // @@protoc_insertion_point(field_add:pipelines.Vector.elements)
}
inline const ::google::protobuf::RepeatedField< float >&
Vector::elements() const {
  // @@protoc_insertion_point(field_list:pipelines.Vector.elements)
  return elements_;
}
inline ::google::protobuf::RepeatedField< float >*
Vector::mutable_elements() {
  // @@protoc_insertion_point(field_mutable_list:pipelines.Vector.elements)
  return &elements_;
}

// -------------------------------------------------------------------

// Naive_bayes

// repeated string classes = 1;
inline int Naive_bayes::classes_size() const {
  return classes_.size();
}
inline void Naive_bayes::clear_classes() {
  classes_.Clear();
}
inline const ::std::string& Naive_bayes::classes(int index) const {
  // @@protoc_insertion_point(field_get:pipelines.Naive_bayes.classes)
  return classes_.Get(index);
}
inline ::std::string* Naive_bayes::mutable_classes(int index) {
  // @@protoc_insertion_point(field_mutable:pipelines.Naive_bayes.classes)
  return classes_.Mutable(index);
}
inline void Naive_bayes::set_classes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pipelines.Naive_bayes.classes)
  classes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Naive_bayes::set_classes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pipelines.Naive_bayes.classes)
  classes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Naive_bayes::set_classes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  classes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pipelines.Naive_bayes.classes)
}
inline void Naive_bayes::set_classes(int index, const char* value, size_t size) {
  classes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pipelines.Naive_bayes.classes)
}
inline ::std::string* Naive_bayes::add_classes() {
  // @@protoc_insertion_point(field_add_mutable:pipelines.Naive_bayes.classes)
  return classes_.Add();
}
inline void Naive_bayes::add_classes(const ::std::string& value) {
  classes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pipelines.Naive_bayes.classes)
}
#if LANG_CXX11
inline void Naive_bayes::add_classes(::std::string&& value) {
  classes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pipelines.Naive_bayes.classes)
}
#endif
inline void Naive_bayes::add_classes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  classes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pipelines.Naive_bayes.classes)
}
inline void Naive_bayes::add_classes(const char* value, size_t size) {
  classes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pipelines.Naive_bayes.classes)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Naive_bayes::classes() const {
  // @@protoc_insertion_point(field_list:pipelines.Naive_bayes.classes)
  return classes_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Naive_bayes::mutable_classes() {
  // @@protoc_insertion_point(field_mutable_list:pipelines.Naive_bayes.classes)
  return &classes_;
}

// repeated .pipelines.Vector vectors = 2;
inline int Naive_bayes::vectors_size() const {
  return vectors_.size();
}
inline void Naive_bayes::clear_vectors() {
  vectors_.Clear();
}
inline ::pipelines::Vector* Naive_bayes::mutable_vectors(int index) {
  // @@protoc_insertion_point(field_mutable:pipelines.Naive_bayes.vectors)
  return vectors_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pipelines::Vector >*
Naive_bayes::mutable_vectors() {
  // @@protoc_insertion_point(field_mutable_list:pipelines.Naive_bayes.vectors)
  return &vectors_;
}
inline const ::pipelines::Vector& Naive_bayes::vectors(int index) const {
  // @@protoc_insertion_point(field_get:pipelines.Naive_bayes.vectors)
  return vectors_.Get(index);
}
inline ::pipelines::Vector* Naive_bayes::add_vectors() {
  // @@protoc_insertion_point(field_add:pipelines.Naive_bayes.vectors)
  return vectors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pipelines::Vector >&
Naive_bayes::vectors() const {
  // @@protoc_insertion_point(field_list:pipelines.Naive_bayes.vectors)
  return vectors_;
}

// repeated float class_priors = 3;
inline int Naive_bayes::class_priors_size() const {
  return class_priors_.size();
}
inline void Naive_bayes::clear_class_priors() {
  class_priors_.Clear();
}
inline float Naive_bayes::class_priors(int index) const {
  // @@protoc_insertion_point(field_get:pipelines.Naive_bayes.class_priors)
  return class_priors_.Get(index);
}
inline void Naive_bayes::set_class_priors(int index, float value) {
  class_priors_.Set(index, value);
  // @@protoc_insertion_point(field_set:pipelines.Naive_bayes.class_priors)
}
inline void Naive_bayes::add_class_priors(float value) {
  class_priors_.Add(value);
  // @@protoc_insertion_point(field_add:pipelines.Naive_bayes.class_priors)
}
inline const ::google::protobuf::RepeatedField< float >&
Naive_bayes::class_priors() const {
  // @@protoc_insertion_point(field_list:pipelines.Naive_bayes.class_priors)
  return class_priors_;
}
inline ::google::protobuf::RepeatedField< float >*
Naive_bayes::mutable_class_priors() {
  // @@protoc_insertion_point(field_mutable_list:pipelines.Naive_bayes.class_priors)
  return &class_priors_;
}

// -------------------------------------------------------------------

// Linear_classifier

// repeated string classes = 1;
inline int Linear_classifier::classes_size() const {
  return classes_.size();
}
inline void Linear_classifier::clear_classes() {
  classes_.Clear();
}
inline const ::std::string& Linear_classifier::classes(int index) const {
  // @@protoc_insertion_point(field_get:pipelines.Linear_classifier.classes)
  return classes_.Get(index);
}
inline ::std::string* Linear_classifier::mutable_classes(int index) {
  // @@protoc_insertion_point(field_mutable:pipelines.Linear_classifier.classes)
  return classes_.Mutable(index);
}
inline void Linear_classifier::set_classes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pipelines.Linear_classifier.classes)
  classes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Linear_classifier::set_classes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pipelines.Linear_classifier.classes)
  classes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Linear_classifier::set_classes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  classes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pipelines.Linear_classifier.classes)
}
inline void Linear_classifier::set_classes(int index, const char* value, size_t size) {
  classes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pipelines.Linear_classifier.classes)
}
inline ::std::string* Linear_classifier::add_classes() {
  // @@protoc_insertion_point(field_add_mutable:pipelines.Linear_classifier.classes)
  return classes_.Add();
}
inline void Linear_classifier::add_classes(const ::std::string& value) {
  classes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pipelines.Linear_classifier.classes)
}
#if LANG_CXX11
inline void Linear_classifier::add_classes(::std::string&& value) {
  classes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pipelines.Linear_classifier.classes)
}
#endif
inline void Linear_classifier::add_classes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  classes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pipelines.Linear_classifier.classes)
}
inline void Linear_classifier::add_classes(const char* value, size_t size) {
  classes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pipelines.Linear_classifier.classes)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Linear_classifier::classes() const {
  // @@protoc_insertion_point(field_list:pipelines.Linear_classifier.classes)
  return classes_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Linear_classifier::mutable_classes() {
  // @@protoc_insertion_point(field_mutable_list:pipelines.Linear_classifier.classes)
  return &classes_;
}

// -------------------------------------------------------------------

// Classifier

// .pipelines.Naive_bayes nb = 1;
inline bool Classifier::has_nb() const {
  return classifier_case() == kNb;
}
inline void Classifier::set_has_nb() {
  _oneof_case_[0] = kNb;
}
inline void Classifier::clear_nb() {
  if (has_nb()) {
    delete classifier_.nb_;
    clear_has_classifier();
  }
}
inline ::pipelines::Naive_bayes* Classifier::release_nb() {
  // @@protoc_insertion_point(field_release:pipelines.Classifier.nb)
  if (has_nb()) {
    clear_has_classifier();
      ::pipelines::Naive_bayes* temp = classifier_.nb_;
    classifier_.nb_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pipelines::Naive_bayes& Classifier::nb() const {
  // @@protoc_insertion_point(field_get:pipelines.Classifier.nb)
  return has_nb()
      ? *classifier_.nb_
      : *reinterpret_cast< ::pipelines::Naive_bayes*>(&::pipelines::_Naive_bayes_default_instance_);
}
inline ::pipelines::Naive_bayes* Classifier::mutable_nb() {
  if (!has_nb()) {
    clear_classifier();
    set_has_nb();
    classifier_.nb_ = CreateMaybeMessage< ::pipelines::Naive_bayes >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pipelines.Classifier.nb)
  return classifier_.nb_;
}

// .pipelines.Linear_classifier lc = 2;
inline bool Classifier::has_lc() const {
  return classifier_case() == kLc;
}
inline void Classifier::set_has_lc() {
  _oneof_case_[0] = kLc;
}
inline void Classifier::clear_lc() {
  if (has_lc()) {
    delete classifier_.lc_;
    clear_has_classifier();
  }
}
inline ::pipelines::Linear_classifier* Classifier::release_lc() {
  // @@protoc_insertion_point(field_release:pipelines.Classifier.lc)
  if (has_lc()) {
    clear_has_classifier();
      ::pipelines::Linear_classifier* temp = classifier_.lc_;
    classifier_.lc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pipelines::Linear_classifier& Classifier::lc() const {
  // @@protoc_insertion_point(field_get:pipelines.Classifier.lc)
  return has_lc()
      ? *classifier_.lc_
      : *reinterpret_cast< ::pipelines::Linear_classifier*>(&::pipelines::_Linear_classifier_default_instance_);
}
inline ::pipelines::Linear_classifier* Classifier::mutable_lc() {
  if (!has_lc()) {
    clear_classifier();
    set_has_lc();
    classifier_.lc_ = CreateMaybeMessage< ::pipelines::Linear_classifier >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:pipelines.Classifier.lc)
  return classifier_.lc_;
}

inline bool Classifier::has_classifier() const {
  return classifier_case() != CLASSIFIER_NOT_SET;
}
inline void Classifier::clear_has_classifier() {
  _oneof_case_[0] = CLASSIFIER_NOT_SET;
}
inline Classifier::ClassifierCase Classifier::classifier_case() const {
  return Classifier::ClassifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Pipeline

// int32 version = 1;
inline void Pipeline::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 Pipeline::version() const {
  // @@protoc_insertion_point(field_get:pipelines.Pipeline.version)
  return version_;
}
inline void Pipeline::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:pipelines.Pipeline.version)
}

// string language = 2;
inline void Pipeline::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Pipeline::language() const {
  // @@protoc_insertion_point(field_get:pipelines.Pipeline.language)
  return language_.GetNoArena();
}
inline void Pipeline::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pipelines.Pipeline.language)
}
#if LANG_CXX11
inline void Pipeline::set_language(::std::string&& value) {
  
  language_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pipelines.Pipeline.language)
}
#endif
inline void Pipeline::set_language(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pipelines.Pipeline.language)
}
inline void Pipeline::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pipelines.Pipeline.language)
}
inline ::std::string* Pipeline::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:pipelines.Pipeline.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pipeline::release_language() {
  // @@protoc_insertion_point(field_release:pipelines.Pipeline.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pipeline::set_allocated_language(::std::string* language) {
  if (language != nullptr) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:pipelines.Pipeline.language)
}

// string timestamp = 3;
inline void Pipeline::clear_timestamp() {
  timestamp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Pipeline::timestamp() const {
  // @@protoc_insertion_point(field_get:pipelines.Pipeline.timestamp)
  return timestamp_.GetNoArena();
}
inline void Pipeline::set_timestamp(const ::std::string& value) {
  
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pipelines.Pipeline.timestamp)
}
#if LANG_CXX11
inline void Pipeline::set_timestamp(::std::string&& value) {
  
  timestamp_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pipelines.Pipeline.timestamp)
}
#endif
inline void Pipeline::set_timestamp(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pipelines.Pipeline.timestamp)
}
inline void Pipeline::set_timestamp(const char* value, size_t size) {
  
  timestamp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pipelines.Pipeline.timestamp)
}
inline ::std::string* Pipeline::mutable_timestamp() {
  
  // @@protoc_insertion_point(field_mutable:pipelines.Pipeline.timestamp)
  return timestamp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Pipeline::release_timestamp() {
  // @@protoc_insertion_point(field_release:pipelines.Pipeline.timestamp)
  
  return timestamp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Pipeline::set_allocated_timestamp(::std::string* timestamp) {
  if (timestamp != nullptr) {
    
  } else {
    
  }
  timestamp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timestamp);
  // @@protoc_insertion_point(field_set_allocated:pipelines.Pipeline.timestamp)
}

// repeated .pipelines.Transformation representation = 4;
inline int Pipeline::representation_size() const {
  return representation_.size();
}
inline void Pipeline::clear_representation() {
  representation_.Clear();
}
inline ::pipelines::Transformation* Pipeline::mutable_representation(int index) {
  // @@protoc_insertion_point(field_mutable:pipelines.Pipeline.representation)
  return representation_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pipelines::Transformation >*
Pipeline::mutable_representation() {
  // @@protoc_insertion_point(field_mutable_list:pipelines.Pipeline.representation)
  return &representation_;
}
inline const ::pipelines::Transformation& Pipeline::representation(int index) const {
  // @@protoc_insertion_point(field_get:pipelines.Pipeline.representation)
  return representation_.Get(index);
}
inline ::pipelines::Transformation* Pipeline::add_representation() {
  // @@protoc_insertion_point(field_add:pipelines.Pipeline.representation)
  return representation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pipelines::Transformation >&
Pipeline::representation() const {
  // @@protoc_insertion_point(field_list:pipelines.Pipeline.representation)
  return representation_;
}

// .pipelines.Classifier classifier = 5;
inline bool Pipeline::has_classifier() const {
  return this != internal_default_instance() && classifier_ != nullptr;
}
inline void Pipeline::clear_classifier() {
  if (GetArenaNoVirtual() == nullptr && classifier_ != nullptr) {
    delete classifier_;
  }
  classifier_ = nullptr;
}
inline const ::pipelines::Classifier& Pipeline::classifier() const {
  const ::pipelines::Classifier* p = classifier_;
  // @@protoc_insertion_point(field_get:pipelines.Pipeline.classifier)
  return p != nullptr ? *p : *reinterpret_cast<const ::pipelines::Classifier*>(
      &::pipelines::_Classifier_default_instance_);
}
inline ::pipelines::Classifier* Pipeline::release_classifier() {
  // @@protoc_insertion_point(field_release:pipelines.Pipeline.classifier)
  
  ::pipelines::Classifier* temp = classifier_;
  classifier_ = nullptr;
  return temp;
}
inline ::pipelines::Classifier* Pipeline::mutable_classifier() {
  
  if (classifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::pipelines::Classifier>(GetArenaNoVirtual());
    classifier_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pipelines.Pipeline.classifier)
  return classifier_;
}
inline void Pipeline::set_allocated_classifier(::pipelines::Classifier* classifier) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete classifier_;
  }
  if (classifier) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      classifier = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, classifier, submessage_arena);
    }
    
  } else {
    
  }
  classifier_ = classifier;
  // @@protoc_insertion_point(field_set_allocated:pipelines.Pipeline.classifier)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pipelines

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_pipeline_2eproto
